#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     armLift,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     driveL,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     spinner,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     bottomLift,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     driveR,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C3_1,     middleLift,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C3_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    hookL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    hookR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_1,    flap,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servo8,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

// Keybinds
#define DRIVE_L (joystick.joy1_y1)
#define DRIVE_R (joystick.joy1_y2)
#define DRIVE_INVERT (joy1Btn(10))

#define BOTTOMLIFT_UP (joy2Btn(1))
#define BOTTOMLIFT_DN (joy2Btn(1))
#define MIDDLELIFT_UP (joy2Btn(1))
#define MIDDLELIFT_DN (joy2Btn(1))
#define ARMLIFT_UP (joy2Btn(1))
#define ARMLIFT_DN (joy2Btn(1))

#define FLAP_TOGGLE (joy2Btn(1))
#define SWEEP_TOGGLE (joy2Btn(1))
#define HOOK_TOGGLE (joy2Btn(3))

// functions
void drive();
void lift();
int translate(int joy);

void setFlapOpen(bool state);
void setHooksDown(bool state);

// variables
bool controlInverted = false;
bool hooksDown = false;
bool flapOpen = false;
bool sweeperOn = false;

void setFlapOpen(bool state)
{
	if (state)
	{
		servo[hookL] = 255;
		servo[hookR] = 0;
	}
	else
	{
		servo[hookL] = 0;
		servo[hookR] = 255;
	}
}

void setHooksDown(bool state)
{
	if (state)
	{
		servo[flap] = 0;
	}
	else
	{
		servo[flap] = 255;
	}
}

task main()
{
	//waitForStart();   // wait for start of tele-op phase

	while (true)
	{
		getJoystickSettings(joystick);

		// toggle drive
		static bool drivePrev = false;
		if (DRIVE_INVERT && !drivePrev)
		{
			drivePrev = true;
			controlInverted = !controlInverted;
		}
		else if (!DRIVE_INVERT)
			drivePrev = false;

		drive();
		lift();

		static bool flapPrevPressed = false;
		if (FLAP_TOGGLE && !flapPrevPressed)
		{
			flapPrevPressed = true;
			flapOpen = !flapOpen;
			if (flapOpen)
			{
				setFlapOpen(true);
			}
			else
			{
				setFlapOpen(false);
			}
		}
		else if (!FLAP_TOGGLE)
			flapPrevPressed = false;

		static bool hookPrevPressed = false;
		if (HOOK_TOGGLE && !hookPrevPressed)
		{
			hookPrevPressed = true;
			hooksDown = !hooksDown;
			if (hooksDown)
			{
				setHooksDown(true);
			}
			else
			{
				setHooksDown(false);
			}
		}
		else if (!HOOK_TOGGLE)
			hookPrevPressed = false;

		static bool sweeperPrevPressed = false;
		if (SWEEP_TOGGLE && !sweeperPrevPressed)
		{
			sweeperPrevPressed = true;
			sweeperOn = !sweeperOn;
			if (sweeperOn)
			{
				motor[spinner] = 100;
			}
			else
			{
				motor[spinner] = 0;
			}
		}
		else if (!SWEEP_TOGGLE)
			sweeperPrevPressed = false;

		wait1Msec(10);
	}
}

void lift()
{
	if (BOTTOMLIFT_UP && !BOTTOMLIFT_DN)
		motor[bottomLift] = 40;
	else if (!BOTTOMLIFT_UP && BOTTOMLIFT_DN)
		motor[bottomLift] = -40;
	else
		motor[bottomLift] = 0;

	if (MIDDLELIFT_UP && !MIDDLELIFT_DN)
		motor[middleLift] = 40;
	else if (!MIDDLELIFT_UP && MIDDLELIFT_DN)
		motor[middleLift] = -40;
	else
		motor[middleLift] = 0;

	if (ARMLIFT_UP && !ARMLIFT_DN)
		motor[armLift] = 40;
	else if (!ARMLIFT_UP && ARMLIFT_DN)
		motor[armLift] = -40;
	else
		motor[armLift] = 0;
}

void drive()
{
	int invert = 1;
	int jl = DRIVE_L, jr = DRIVE_R;

	if (controlInverted)
	{
		int swap = jl;
		jl = jr;
		jr = swap;
		invert = -1;
	}

	if (abs(jl) > 10)
		motor[driveL] = invert * translate(jl);
	else
		motor[driveL] = 0;

	if (abs(jr) > 10)
		motor[driveR] = invert * translate(jr);
	else
		motor[driveR] = 0;
}

int translate(int joy)
{
	return (int)((float)joy * 0.78 + 0.5);
}
