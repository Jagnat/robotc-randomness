#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     rightf,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightb,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     leftf,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     leftb,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     sweeper,       tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    hookr,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    hookl,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    flap,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    fflap,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    autoarm,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

// Keybinds
// Joy 1
#define SWEEPERFWD joy1Btn(6)
#define SWEEPERBWD joy1Btn(5)
#define CONTROLTOGGLE joy1Btn(10)
// Joy 2
#define LIFTUP (joystick.joy2_TopHat == 0)
#define LIFTDN (joystick.joy2_TopHat == 4)
#define HOOKTOGGLE joy2Btn(2)
#define FLAPTOGGLE joy2Btn(4)
#define FFLAPTOGGLE joy2Btn(1)

// Variables
bool hookPrevPressed = false;
bool flapPrevPressed = false;
bool controlInvertLastPressed = false;
bool sweeperPrevPressed = false;
bool fFlapPrevPressed = false;
// false - up, true - down
bool hookState = false;
// false - closed, true - open
bool flapState = false;
// false - not inverted, true - inverted
bool controlState = false;
// 0 - off, 1 - fwd, 2 - bwd
int sweeperState = 0;
// 0 is down, 1 = 30cm, 2 = 60cm, 3 = 90cm
// unused
int liftPosition = 0;

// Translate joystick values to motor values
int translate(int x)
{
	return (int)((float)x * 0.78 + 0.5);
}

// Function that takes in joystick inputs
// and sets base motors based on joystick
// values and the state of the inverted controls
void drive(int jr, int jl)
{
	int invert = 1;
	int jrReal = jr;
	int jlReal = jl;

	// If our controls are inverted,
	// swap joysticks, and multiply by -1 instead of 1
	if (controlState)
	{
		jrReal = jl;
		jlReal = jr;
		invert = -1;
	}

	// Deadband
	if (abs(jlReal) > 10)
	{
		motor[rightf] = invert * translate(jlReal);
		motor[rightb] = invert * translate(jlReal);
	}
	else
	{
		motor[rightf] = 0;
		motor[rightb] = 0;
	}

	if (abs(jrReal) > 10)
	{
		motor[leftf] = invert * translate(jrReal);
		motor[leftb] = invert * translate(jrReal);
	}
	else
	{
		motor[leftf] = 0;
		motor[leftb] = 0;
	}
}

// Entry point
task main()
{
	// Initialize servos to the correct position
	servo[hookl] = 255;
	servo[hookr] = 0;
	servo[flap] = 255;
	servo[fflap] = 127;
	servo[autoarm] = 200;
	waitForStart();

	servo[hookl] = 140;
	servo[hookr] = 100;

	// Main loop
	while (1)
	{
		// Poll joysticks
		getJoystickSettings(joystick);

		// Toggles are managed by keeping track of input
		// state between iterations, and only activating
		// an input if the state of the last iteration
		// is false, and the state of this iteration
		// is true.

		// Invert driver control toggle
		if (CONTROLTOGGLE && !controlInvertLastPressed)
		{
			controlInvertLastPressed = true;
			// Set the control state to its inverse
			controlState = !controlState;
			if (controlState)
				servo[autoarm] = 127;
			else
				servo[autoarm] = 200;
		}
		else if (!CONTROLTOGGLE)
			controlInvertLastPressed = false;

		// Now that our inverted control state is updated,
		// we can set the base motors
		drive(joystick.joy1_y2, joystick.joy1_y1);

		// Sweeper toggle
		if ((SWEEPERFWD) && !sweeperPrevPressed)
		{
			sweeperPrevPressed = true;
			if (sweeperState == 0)
				sweeperState = 1;
			else
				sweeperState = 0;
		}
		else if (!SWEEPERFWD)
			sweeperPrevPressed = false;

		// Set sweeper motor based on sweeper toggle state
		if (sweeperState == 1)
			motor[sweeper] = -100;
		else
			motor[sweeper] = 0;

		// Lift - monitors two buttons,
		// and sets the power accordingly.
		if (LIFTUP && !LIFTDN)
		{
			motor[lift] = 50;
		}
		else if (!LIFTUP && LIFTDN)
		{
			motor[lift] = -50;
		}
		else
		{
			motor[lift] = 0;
		}

		// Box flap servo toggle -
		// holds a boolean flag even
		// though we could read servo position,
		// to allow for unusual servo values.
		if (FLAPTOGGLE && !flapPrevPressed)
		{
			// Toggle flap
			flapPrevPressed = true;
			if (flapState == false)
			{
				// Set flap up
				flapState = true;
				servo[flap] = 128;
			}
			else
			{
				// Set flap down
				flapState = false;
				servo[flap] = 255;
			}
		}
		else if (!FLAPTOGGLE)
			flapPrevPressed = false;

		if (FFLAPTOGGLE && !fFlapPrevPressed)
		{
			fFlapPrevPressed = true;
			if (servo[fflap] == 127)
				servo[fflap] = 255;
			else
				servo[fflap] = 127;
		}
		else if (!FFLAPTOGGLE)
			fFlapPrevPressed = false;

		// Hook toggle
		if (HOOKTOGGLE && !hookPrevPressed)
		{
			hookPrevPressed = true;

			if (hookState == false)
			{
				// Set to down
				servo[hookl] = 50;
				servo[hookr] = 185;
				hookState = true;
			}
			else
			{
				// Set to up
				servo[hookl] = 140;
				servo[hookr] = 100;
				hookState = false;
			}
		}
		else if (!HOOKTOGGLE)
			hookPrevPressed = false;
	}
}
